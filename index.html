<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Sniper Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.com/libraries/tone"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #000; color: #fff; }
        #gameContainer { width: 100vw; height: 100vh; display: block; cursor: crosshair; }
        #uiOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through to the canvas */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            color: white;
            font-size: 16px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }
        .ui-panel {
            background-color: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 8px;
            margin: 20px;
            text-align: center;
            min-width: 120px;
        }
        .top-ui { display: flex; justify-content: space-between; width: 100%; }
        .center-message { font-size: 24px; font-weight: bold; background-color: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px;}
        #scopeOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%"><line x1="50%" y1="0" x2="50%" y2="100%" stroke="rgba(0,0,0,0.7)" stroke-width="2"/><line x1="0" y1="50%" x2="100%" y2="50%" stroke="rgba(0,0,0,0.7)" stroke-width="2"/><line x1="50%" y1="40%" x2="50%" y2="42%" stroke="black" stroke-width="1"/><line x1="50%" y1="58%" x2="50%" y2="60%" stroke="black" stroke-width="1"/><line x1="40%" y1="50%" x2="42%" y2="50%" stroke="black" stroke-width="1"/><line x1="58%" y1="50%" x2="60%" y2="50%" stroke="black" stroke-width="1"/><circle cx="50%" cy="50%" r="1%" fill="red"/></svg>');
            background-size: 100% 100%;
            display: none; /* Hidden by default */
            pointer-events: none;
            z-index: 10;
        }
        #scopeLensEffect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            box-shadow: inset 0 0 0 100vw rgba(0,0,0,0.8); /* Creates the dark vignette effect */
            display: none; /* Hidden by default */
            pointer-events: none;
            z-index: 9;
        }
        #instructions, #gameOverScreen, #modeSelectionScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.85);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 100;
            width: 90%;
            max-width: 500px;
        }
        #instructions button, #gameOverScreen button, #modeSelectionScreen button {
            background-color: #4CAF50;
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            cursor: pointer;
            margin-top: 20px;
            transition: background-color 0.3s ease;
            pointer-events: all;
            margin: 10px;
        }
        #instructions button:hover, #gameOverScreen button:hover, #modeSelectionScreen button:hover {
            background-color: #45a049;
        }
        #gameOverScreen {
            display: none;
        }
        #modeSelectionScreen {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h2 class="text-3xl font-bold mb-4">Sniper Challenge</h2>
        <p class="mb-2">Use your mouse to aim.</p>
        <p class="mb-2">Left-click to shoot (ðŸ’€ and ðŸ˜› modes).</p>
        <p class="mb-2">Right-click to toggle scope.</p>
        <p class="mb-4">Track the target in ðŸ”« mode.</p>
        <button id="startButton">Start Game</button>
    </div>

    <div id="modeSelectionScreen" style="display: none;">
        <h2 class="text-3xl font-bold mb-4">Select Game Mode</h2>
        <button id="skullModeButton">ðŸ’€ Mode (Super Hard)</button>
        <button id="pepModeButton">ðŸ˜› Mode (Relaxed)</button>
        <button id="gunModeButton">ðŸ”« Mode (Tracking)</button>
    </div>

    <div id="gameOverScreen">
        <h2 class="text-3xl font-bold mb-4" id="gameOverTitle">Game Over</h2>
        <p class="mb-2 text-xl" id="gameOverMessage">Your final score: <span id="finalScore">0</span></p>
        <button id="playAgainButton">Play Again</button>
    </div>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div id="uiOverlay">
        <div class="top-ui">
            <div id="scorePanel" class="ui-panel">Score: 0</div>
            <div id="modePanel" class="ui-panel">Mode: N/A</div>
            <div id="ammoPanel" class="ui-panel">Ammo: âˆž</div>
        </div>
        <div id="messagePanel" class="center-message" style="display: none;"></div>
        <div class="ui-panel" id="targetsLeftPanel">Targets: âˆž</div>
    </div>
    <div id="scopeOverlay"></div>
    <div id="scopeLensEffect"></div>

    <script type="module">
        // --- Game State & Variables ---
        let scene, camera, renderer, raycaster;
        let sniperRifle;
        let activeTargets = [];
        let particles = [];
        let score = 0;
        let ammo;
        let isScoped = false;
        const normalFov = 75, scopedFov = 15;
        let gameStarted = false;
        let currentMode = ''; // 'skull', 'pep', 'gun'

        // Tracking Mode Variables
        let trackingScore = 0;
        let targetOnScreen = false;
        let targetCenterDistance = 0;
        const trackingPerfectThreshold = 0.05; // Percentage of screen width/height

        // --- DOM Elements ---
        const gameCanvas = document.getElementById('gameCanvas');
        const scorePanel = document.getElementById('scorePanel');
        const modePanel = document.getElementById('modePanel');
        const ammoPanel = document.getElementById('ammoPanel');
        const messagePanel = document.getElementById('messagePanel');
        const targetsLeftPanel = document.getElementById('targetsLeftPanel');
        const scopeOverlay = document.getElementById('scopeOverlay');
        const scopeLensEffect = document.getElementById('scopeLensEffect');
        const instructions = document.getElementById('instructions');
        const startButton = document.getElementById('startButton');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const gameOverTitle = document.getElementById('gameOverTitle');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const finalScoreSpan = document.getElementById('finalScore');
        const playAgainButton = document.getElementById('playAgainButton');
        const modeSelectionScreen = document.getElementById('modeSelectionScreen');
        const skullModeButton = document.getElementById('skullModeButton');
        const pepModeButton = document.getElementById('pepModeButton');
        const gunModeButton = document.getElementById('gunModeButton');


        // --- Sound Effects ---
        let shotSound, hitSound, dryFireSound, levelUpSound, explosionSound, trackingScoreSound;

        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);

            camera = new THREE.PerspectiveCamera(normalFov, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ canvas: gameCanvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, side: THREE.DoubleSide });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            createSniperRifle();
            raycaster = new THREE.Raycaster();
            setupSounds();
            setupEventListeners();
            animate();
        }

        function createSniperRifle() {
            sniperRifle = new THREE.Group();
            const material = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.4, metalness: 0.6 });
            const scopeMaterial = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 1.2, 16), material);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.set(0, -0.05, -0.6);
            sniperRifle.add(barrel);
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.7), material);
            body.position.set(0, -0.15, -0.2);
            sniperRifle.add(body);
            const scopeTube = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.4, 16), scopeMaterial);
            scopeTube.rotation.x = Math.PI / 2;
            scopeTube.position.set(0, 0.05, -0.3);
            sniperRifle.add(scopeTube);
            sniperRifle.position.set(0.25, -0.3, -0.8);
            sniperRifle.rotation.y = -0.05;
            camera.add(sniperRifle);
        }

        function setupSounds() {
            try {
                shotSound = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
                hitSound = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 6, envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.2 } }).toDestination();
                hitSound.volume.value = -10;
                dryFireSound = new Tone.Player("data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA").toDestination();
                levelUpSound = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.05, decay: 0.2, sustain: 0.5, release: 0.8 } }).toDestination();
                explosionSound = new Tone.NoiseSynth({ noise: { type: "pink", playbackRate: 0.5 }, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.2 } }).toDestination();
                explosionSound.volume.value = -5;
                trackingScoreSound = new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
                trackingScoreSound.volume.value = -15; // Quieter sound
            } catch (e) {
                console.error("Error initializing sounds:", e);
            }
        }

        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('contextmenu', (event) => event.preventDefault());
            startButton.addEventListener('click', showModeSelection);
            playAgainButton.addEventListener('click', showModeSelection);
            skullModeButton.addEventListener('click', () => startGame('skull'));
            pepModeButton.addEventListener('click', () => startGame('pep'));
            gunModeButton.addEventListener('click', () => startGame('gun'));
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement !== gameCanvas && isScoped) toggleScope();
                if (document.pointerLockElement !== gameCanvas && gameStarted) {
                    // Game was running, pointer lock lost, maybe pause or show game over
                    if (currentMode !== 'gun') { // Only game over on non-tracking modes for now
                        gameOver("Pointer Lock Lost! Game Over.", score);
                    } else {
                        // For gun mode, just pause tracking or show a message
                        showMessage("Pointer Lock Lost. Click to resume tracking.", 99999);
                        gameStarted = false; // Effectively pause
                    }
                } else if (document.pointerLockElement === gameCanvas && !gameStarted && currentMode !== '') {
                    // Re-engaged pointer lock after losing it, resume game
                    startGame(currentMode);
                }
            }, false);
        }

        // --- Game Logic ---
        function showModeSelection() {
            instructions.style.display = 'none';
            gameOverScreen.style.display = 'none';
            modeSelectionScreen.style.display = 'flex';
        }

        async function startGame(mode) {
            modeSelectionScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            instructions.style.display = 'none';

            if (Tone.context.state !== 'running') {
                try { await Tone.start(); } catch (e) { console.error("AudioContext start failed:", e); }
            }
            
            score = 0;
            trackingScore = 0;
            gameStarted = true;
            currentMode = mode;
            ammo = (currentMode === 'skull' || currentMode === 'pep') ? Infinity : 0; // Ammo only for shooting modes

            // Clear existing targets and particles
            activeTargets.forEach(target => { if (target.mesh && target.mesh.parent) scene.remove(target.mesh); });
            activeTargets = [];
            particles.forEach(p => { if (p.mesh.parent) scene.remove(p.mesh); });
            particles = [];

            if (currentMode === 'gun') {
                // For gun mode, ensure the rifle is hidden as there's no shooting
                if (sniperRifle) sniperRifle.visible = false;
                // Add a target for tracking
                spawnNewTarget();
                showMessage("Track the target!", 3000);
            } else {
                if (sniperRifle) sniperRifle.visible = true;
                spawnNewTarget(); // Spawn the first target immediately
                showMessage(`Welcome to ${currentMode.toUpperCase()} mode!`, 3000);
            }
            
            updateUI();
            if (document.pointerLockElement !== gameCanvas) gameCanvas.requestPointerLock();
        }

        function spawnNewTarget() {
            // Remove existing targets before spawning new ones for infinite modes
            activeTargets.forEach(target => {
                if (target.mesh && target.mesh.parent) scene.remove(target.mesh);
            });
            activeTargets = [];

            let targetData = {};
            const minZ = -80, maxZ = -30;
            const minY = 2, maxY = 15;
            const minX = -30, maxX = 30;

            const randomPos = new THREE.Vector3(
                THREE.MathUtils.randFloat(minX, maxX),
                THREE.MathUtils.randFloat(minY, maxY),
                THREE.MathUtils.randFloat(minZ, maxZ)
            );

            if (currentMode === 'skull') {
                const randomSize = THREE.MathUtils.randFloat(0.2, 0.6); // Varying sizes
                targetData = {
                    pos: randomPos,
                    size: { rTop: randomSize, rBottom: randomSize, h: randomSize * 8 },
                    color: new THREE.Color(Math.random() * 0xffffff),
                    points: 10 + Math.floor(Math.random() * 20), // Varying points
                    moving: true,
                    moveAxis: ['x', 'y', 'z', 'xy', 'xz', 'yz'][Math.floor(Math.random() * 6)], // Random axis
                    moveRange: THREE.MathUtils.randFloat(10, 30), // Larger range
                    moveSpeed: THREE.MathUtils.randFloat(0.05, 0.15) // Faster speed
                };
            } else if (currentMode === 'pep') {
                targetData = {
                    pos: randomPos,
                    size: { rTop: 0.4, rBottom: 0.4, h: 3.5 }, // Fixed size
                    color: 0xff0000,
                    points: 5, // Fixed points
                    moving: false
                };
            } else if (currentMode === 'gun') {
                const randomSize = 0.5; // Fixed size for tracking clarity
                targetData = {
                    pos: randomPos,
                    size: { rTop: randomSize, rBottom: randomSize, h: randomSize * 8 },
                    color: 0x00ffff, // Distinct color for tracking
                    points: 0, // No shooting points
                    moving: true,
                    moveAxis: ['x', 'y', 'z', 'xy', 'xz', 'yz'][Math.floor(Math.random() * 6)],
                    moveRange: THREE.MathUtils.randFloat(15, 40), // Larger range for tracking
                    moveSpeed: THREE.MathUtils.randFloat(0.06, 0.18) // Faster speed for tracking
                };
            }

            const targetMesh = createTarget(targetData);
            scene.add(targetMesh);
            activeTargets.push({ mesh: targetMesh, hit: false, ...targetData });
            targetOnScreen = true; // For gun mode, assume target is spawned and visible
            updateUI();
        }

        function gameOver(title, finalScore) {
            gameStarted = false;
            gameOverTitle.textContent = title;
            finalScoreSpan.textContent = finalScore;
            gameOverScreen.style.display = 'flex';
            if (document.pointerLockElement) document.exitPointerLock();
        }

        function shoot() {
            if (!gameStarted || currentMode === 'gun') return; // Cannot shoot in gun mode
            if (ammo <= 0) {
                if (dryFireSound && dryFireSound.loaded && Tone.context.state === 'running') dryFireSound.start();
                return;
            }

            // Ammo is infinite in these modes, so no decrement
            // ammo--; 
            
            if (shotSound && Tone.context.state === 'running') shotSound.triggerAttackRelease("8n");

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const liveTargets = activeTargets.filter(t => !t.hit).map(t => t.mesh);
            const intersects = raycaster.intersectObjects(liveTargets);

            if (intersects.length > 0) {
                const hitObject = intersects[0].object;
                const targetData = activeTargets.find(t => t.mesh === hitObject);

                if (targetData && !targetData.hit) {
                    targetData.hit = true;
                    score += targetData.points;
                    if (hitSound && Tone.context.state === 'running') hitSound.triggerAttackRelease("C2", "8n");
                    if (explosionSound && Tone.context.state === 'running') explosionSound.triggerAttackRelease("8n");
                    
                    createExplosion(hitObject.position.clone(), hitObject.material.color.clone());
                    if (hitObject.parent) scene.remove(hitObject);
                    
                    // Immediately spawn a new target
                    spawnNewTarget();
                }
            }
            updateUI();
        }

        // --- Event Handlers & UI ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            if (!gameStarted || document.pointerLockElement !== gameCanvas) return;
            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;
            const sensitivity = isScoped ? 0.001 : 0.002;
            camera.rotation.y -= movementX * sensitivity;
            camera.rotation.x -= movementY * sensitivity;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
        }

        function onMouseDown(event) {
            if (!gameStarted) {
                if (document.pointerLockElement !== gameCanvas) {
                    gameCanvas.requestPointerLock();
                }
                return;
            }
            
            if (document.pointerLockElement !== gameCanvas) {
                gameCanvas.requestPointerLock();
                return;
            }
            if (event.button === 0 && (currentMode === 'skull' || currentMode === 'pep')) shoot();
            else if (event.button === 2) toggleScope();
        }

        function toggleScope() {
            if (!gameStarted) return;
            isScoped = !isScoped;
            camera.fov = isScoped ? scopedFov : normalFov;
            scopeOverlay.style.display = isScoped ? 'block' : 'none';
            scopeLensEffect.style.display = isScoped ? 'block' : 'none';
            if (sniperRifle) sniperRifle.visible = !isScoped;
            camera.updateProjectionMatrix();
        }

        function updateUI() {
            scorePanel.textContent = `Score: ${score}`;
            modePanel.textContent = `Mode: ${currentMode === 'skull' ? 'ðŸ’€' : currentMode === 'pep' ? 'ðŸ˜›' : 'ðŸ”«'}`;
            ammoPanel.textContent = `Ammo: ${currentMode === 'gun' ? 'N/A' : 'âˆž'}`;
            targetsLeftPanel.textContent = `Targets: âˆž`;

            if (currentMode === 'gun') {
                scorePanel.textContent = `Tracking Score: ${Math.floor(trackingScore)}`;
            }
        }

        function showMessage(msg, duration = 2000, color = 'white') {
            messagePanel.textContent = msg;
            messagePanel.style.color = color;
            messagePanel.style.display = 'block';
            setTimeout(() => { messagePanel.style.display = 'none'; }, duration);
        }

        // --- Effects & Animation ---
        function createTarget(targetData) {
            const geometry = new THREE.CylinderGeometry(targetData.size.rTop, targetData.size.rBottom, targetData.size.h, 16);
            const material = new THREE.MeshStandardMaterial({ color: targetData.color });
            const cylinder = new THREE.Mesh(geometry, material);
            cylinder.position.copy(targetData.pos);
            cylinder.castShadow = true;
            cylinder.userData = { ...targetData };
            return cylinder;
        }

        function createExplosion(position, color) {
            const particleCount = 20;
            const particleMaterial = new THREE.MeshBasicMaterial({ color: color, transparent: true });
            const particleGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            for (let i = 0; i < particleCount; i++) {
                const particleMesh = new THREE.Mesh(particleGeometry, particleMaterial.clone());
                particleMesh.position.copy(position);
                const velocity = new THREE.Vector3((Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)).normalize().multiplyScalar(0.5);
                particles.push({ mesh: particleMesh, velocity: velocity, life: 1.0 });
                scene.add(particleMesh);
            }
        }

        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.velocity.y -= 0.005; // Gravity
                p.mesh.position.add(p.velocity);
                p.life -= deltaTime * 1.5;
                p.mesh.material.opacity = p.life;
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    if (p.mesh.geometry) p.mesh.geometry.dispose();
                    if (p.mesh.material) p.mesh.material.dispose();
                    particles.splice(i, 1);
                }
            }
        }

        function updateMovingTargets() {
            if (!gameStarted) return;
            activeTargets.forEach(targetData => {
                if (targetData.moving && !targetData.hit) {
                    const target = targetData.mesh;
                    const moveData = target.userData;
                    if (!moveData.initialPos) moveData.initialPos = target.position.clone();

                    const timeFactor = Date.now() * 0.001 * moveData.moveSpeed * 100;
                    const range = moveData.moveRange / 2;

                    switch (moveData.moveAxis) {
                        case 'x':
                            target.position.x = moveData.initialPos.x + Math.sin(timeFactor) * range;
                            break;
                        case 'y':
                            target.position.y = moveData.initialPos.y + Math.sin(timeFactor) * range;
                            break;
                        case 'z':
                            target.position.z = moveData.initialPos.z + Math.sin(timeFactor) * range;
                            break;
                        case 'xy':
                            target.position.x = moveData.initialPos.x + Math.sin(timeFactor) * range;
                            target.position.y = moveData.initialPos.y + Math.cos(timeFactor) * range;
                            break;
                        case 'xz':
                            target.position.x = moveData.initialPos.x + Math.sin(timeFactor) * range;
                            target.position.z = moveData.initialPos.z + Math.cos(timeFactor) * range;
                            break;
                        case 'yz':
                            target.position.y = moveData.initialPos.y + Math.sin(timeFactor) * range;
                            target.position.z = moveData.initialPos.z + Math.cos(timeFactor) * range;
                            break;
                        default:
                            break;
                    }
                }
            });
        }

        function updateTrackingMode(deltaTime) {
            if (currentMode !== 'gun' || !gameStarted || activeTargets.length === 0) return;

            const targetMesh = activeTargets[0].mesh;
            if (!targetMesh) {
                targetOnScreen = false;
                return;
            }

            // Project target position to screen space
            const vector = new THREE.Vector3();
            targetMesh.getWorldPosition(vector);
            vector.project(camera);

            // Normalize to -1 to 1 range
            const screenX = (vector.x + 1) / 2;
            const screenY = (vector.y + 1) / 2;

            // Check if target is on screen
            targetOnScreen = (screenX >= 0 && screenX <= 1 && screenY >= 0 && screenY <= 1);

            if (targetOnScreen) {
                // Calculate distance from center (0.5, 0.5)
                const distanceX = Math.abs(screenX - 0.5);
                const distanceY = Math.abs(screenY - 0.5);
                targetCenterDistance = Math.max(distanceX, distanceY);

                if (targetCenterDistance <= trackingPerfectThreshold) {
                    trackingScore += deltaTime * 10; // More points for being perfectly centered
                    if (trackingScoreSound && Tone.context.state === 'running') {
                        trackingScoreSound.triggerAttackRelease("C4", "32n");
                    }
                } else if (targetCenterDistance <= 0.2) { // Within a wider acceptable range
                    trackingScore += deltaTime * 5;
                } else {
                    trackingScore += deltaTime * 1; // Minimal points if just on screen
                }
            } else {
                trackingScore = Math.max(0, trackingScore - deltaTime * 20); // Penalize heavily for losing target
            }
            updateUI();
        }

        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            const deltaTime = (time - (lastTime || time)) / 1000;
            lastTime = time;
            updateParticles(deltaTime);
            updateMovingTargets();
            updateTrackingMode(deltaTime);
            renderer.render(scene, camera);
        }

        // --- Start Application ---
        init();
    </script>
</body>
</html>
