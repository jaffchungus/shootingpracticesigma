<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Sniper Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #000; color: #fff; }
        #gameContainer { width: 100vw; height: 100vh; display: block; cursor: crosshair; }
        #uiOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through to the canvas */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            color: white;
            font-size: 16px;
        }
        .ui-panel {
            background-color: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 8px;
            margin: 20px;
            text-align: center;
        }
        .top-ui { display: flex; justify-content: space-between; width: 100%; }
        .center-message { font-size: 24px; font-weight: bold; background-color: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px;}
        #scopeOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%"><line x1="50%" y1="0" x2="50%" y2="100%" stroke="rgba(0,0,0,0.7)" stroke-width="2"/><line x1="0" y1="50%" x2="100%" y2="50%" stroke="rgba(0,0,0,0.7)" stroke-width="2"/><line x1="50%" y1="40%" x2="50%" y2="42%" stroke="black" stroke-width="1"/><line x1="50%" y1="58%" x2="50%" y2="60%" stroke="black" stroke-width="1"/><line x1="40%" y1="50%" x2="42%" y2="50%" stroke="black" stroke-width="1"/><line x1="58%" y1="50%" x2="60%" y2="50%" stroke="black" stroke-width="1"/><circle cx="50%" cy="50%" r="1%" fill="red"/></svg>');
            background-size: 100% 100%;
            display: none; /* Hidden by default */
            pointer-events: none;
            z-index: 10;
        }
        #scopeLensEffect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            box-shadow: inset 0 0 0 100vw rgba(0,0,0,0.8); /* Creates the dark vignette effect */
            display: none; /* Hidden by default */
            pointer-events: none;
            z-index: 9;
        }
        #instructions, #gameOverScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.85);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 100;
            width: 90%;
            max-width: 500px;
        }
        #instructions button, #gameOverScreen button {
            background-color: #4CAF50;
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            cursor: pointer;
            margin-top: 20px;
            transition: background-color 0.3s ease;
            pointer-events: all;
        }
        #instructions button:hover, #gameOverScreen button:hover {
            background-color: #45a049;
        }
        #gameOverScreen {
            display: none;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h2 class="text-3xl font-bold mb-4">Sniper Challenge</h2>
        <p class="mb-2">Use your mouse to aim.</p>
        <p class="mb-2">Left-click to shoot.</p>
        <p class="mb-2">Right-click to toggle scope.</p>
        <p class="mb-4">Eliminate all targets to advance to the next level.</p>
        <button id="startButton">Start Game</button>
    </div>

    <div id="gameOverScreen">
        <h2 class="text-3xl font-bold mb-4" id="gameOverTitle">Game Over</h2>
        <p class="mb-2 text-xl" id="gameOverMessage">Your final score: <span id="finalScore">0</span></p>
        <button id="playAgainButton">Play Again</button>
    </div>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div id="uiOverlay">
        <div class="top-ui">
            <div id="scorePanel" class="ui-panel">Score: 0</div>
            <div id="levelPanel" class="ui-panel">Level: 1</div>
            <div id="ammoPanel" class="ui-panel">Ammo: 10/10</div>
        </div>
        <div id="messagePanel" class="center-message" style="display: none;"></div>
        <div class="ui-panel" id="targetsLeftPanel">Targets Left: 0</div>
    </div>
    <div id="scopeOverlay"></div>
    <div id="scopeLensEffect"></div>

    <script type="module">
        // --- Game State & Variables ---
        let scene, camera, renderer, raycaster;
        let sniperRifle;
        let activeTargets = [];
        let particles = [];
        let currentLevel = 0;
        let score = 0;
        let ammo, maxAmmo;
        let isScoped = false;
        const normalFov = 75, scopedFov = 15;
        let gameStarted = false;
        let levelInProgress = false;

        // --- DOM Elements ---
        const gameCanvas = document.getElementById('gameCanvas');
        const scorePanel = document.getElementById('scorePanel');
        const levelPanel = document.getElementById('levelPanel');
        const ammoPanel = document.getElementById('ammoPanel');
        const messagePanel = document.getElementById('messagePanel');
        const targetsLeftPanel = document.getElementById('targetsLeftPanel');
        const scopeOverlay = document.getElementById('scopeOverlay');
        const scopeLensEffect = document.getElementById('scopeLensEffect');
        const instructions = document.getElementById('instructions');
        const startButton = document.getElementById('startButton');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const gameOverTitle = document.getElementById('gameOverTitle');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const finalScoreSpan = document.getElementById('finalScore');
        const playAgainButton = document.getElementById('playAgainButton');

        // --- Sound Effects ---
        let shotSound, hitSound, dryFireSound, levelUpSound, explosionSound;

        // --- Level Definitions ---
        const gameLevels = [
            { ammo: 5, targets: [ { pos: new THREE.Vector3(0, 2, -30), size: { rTop: 0.5, rBottom: 0.5, h: 4 }, color: 0xff0000, points: 10 } ], message: "Basic Training" },
            { ammo: 8, targets: [ { pos: new THREE.Vector3(-15, 2, -50), size: { rTop: 0.4, rBottom: 0.4, h: 3.5 }, color: 0xff0000, points: 10 }, { pos: new THREE.Vector3(15, 2, -50), size: { rTop: 0.4, rBottom: 0.4, h: 3.5 }, color: 0xff8800, points: 10 } ], message: "Two Targets" },
            { ammo: 10, targets: [ { pos: new THREE.Vector3(0, 5, -70), size: { rTop: 0.3, rBottom: 0.3, h: 3 }, color: 0xffff00, points: 15 }, { pos: new THREE.Vector3(-25, 2, -60), size: { rTop: 0.4, rBottom: 0.4, h: 3.5 }, color: 0xff0000, points: 10 }, { pos: new THREE.Vector3(25, 2, -60), size: { rTop: 0.4, rBottom: 0.4, h: 3.5 }, color: 0xff0000, points: 10 } ], message: "Distance and Spread" },
            { ammo: 12, targets: [ { pos: new THREE.Vector3(-30, 3, -80), size: { rTop: 0.3, rBottom: 0.3, h: 3 }, color: 0x00ff00, points: 20, moving: true, moveAxis: 'x', moveRange: 20, moveSpeed: 0.02 }, { pos: new THREE.Vector3(30, 3, -80), size: { rTop: 0.3, rBottom: 0.3, h: 3 }, color: 0x00ff00, points: 20, moving: true, moveAxis: 'x', moveRange: 20, moveSpeed: -0.02 }, { pos: new THREE.Vector3(0, 2, -40), size: { rTop: 0.5, rBottom: 0.5, h: 4 }, color: 0xff0000, points: 10 } ], message: "Moving Targets!" },
            { ammo: 15, targets: [ { pos: new THREE.Vector3(0, 10, -100), size: { rTop: 0.2, rBottom: 0.2, h: 2.5 }, color: 0x00ffff, points: 30 }, { pos: new THREE.Vector3(-40, 2, -90), size: { rTop: 0.3, rBottom: 0.3, h: 3 }, color: 0xff00ff, points: 25, moving: true, moveAxis: 'y', moveRange: 5, moveSpeed: 0.03 }, { pos: new THREE.Vector3(40, 2, -90), size: { rTop: 0.3, rBottom: 0.3, h: 3 }, color: 0xff00ff, points: 25, moving: true, moveAxis: 'y', moveRange: 5, moveSpeed: -0.03 }, { pos: new THREE.Vector3(0, 2, -60), size: { rTop: 0.4, rBottom: 0.4, h: 3.5 }, color: 0xffff00, points: 15, moving: true, moveAxis: 'x', moveRange: 30, moveSpeed: 0.04 } ], message: "Increased Complexity" }
        ];

        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);

            camera = new THREE.PerspectiveCamera(normalFov, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ canvas: gameCanvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, side: THREE.DoubleSide });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            createSniperRifle();
            raycaster = new THREE.Raycaster();
            setupSounds();
            setupEventListeners();
            animate();
        }

        function createSniperRifle() {
            sniperRifle = new THREE.Group();
            const material = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.4, metalness: 0.6 });
            const scopeMaterial = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 1.2, 16), material);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.set(0, -0.05, -0.6);
            sniperRifle.add(barrel);
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.7), material);
            body.position.set(0, -0.15, -0.2);
            sniperRifle.add(body);
            const scopeTube = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.4, 16), scopeMaterial);
            scopeTube.rotation.x = Math.PI / 2;
            scopeTube.position.set(0, 0.05, -0.3);
            sniperRifle.add(scopeTube);
            sniperRifle.position.set(0.25, -0.3, -0.8);
            sniperRifle.rotation.y = -0.05;
            camera.add(sniperRifle);
        }

        function setupSounds() {
            try {
                shotSound = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
                hitSound = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 6, envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.2 } }).toDestination();
                hitSound.volume.value = -10;
                dryFireSound = new Tone.Player("data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA").toDestination();
                levelUpSound = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.05, decay: 0.2, sustain: 0.5, release: 0.8 } }).toDestination();
                explosionSound = new Tone.NoiseSynth({ noise: { type: "pink", playbackRate: 0.5 }, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.2 } }).toDestination();
                explosionSound.volume.value = -5;
            } catch (e) {
                console.error("Error initializing sounds:", e);
            }
        }

        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('contextmenu', (event) => event.preventDefault());
            startButton.addEventListener('click', startGame);
            playAgainButton.addEventListener('click', startGame);
            document.addEventListener('pointerlockchange', () => { if (document.pointerLockElement !== gameCanvas && isScoped) toggleScope(); }, false);
        }

        // --- Game Logic ---
        async function startGame() {
            instructions.style.display = 'none';
            gameOverScreen.style.display = 'none';

            if (Tone.context.state !== 'running') {
                try { await Tone.start(); } catch (e) { console.error("AudioContext start failed:", e); }
            }
            
            currentLevel = 0;
            score = 0;
            gameStarted = true;
            
            loadLevel(currentLevel);
            if (document.pointerLockElement !== gameCanvas) gameCanvas.requestPointerLock();
        }

        function loadLevel(levelIndex) {
            levelInProgress = false;
            
            activeTargets.forEach(target => {
                if (target.mesh && target.mesh.parent) scene.remove(target.mesh);
            });
            activeTargets = [];
            particles.forEach(p => {
                if (p.mesh.parent) scene.remove(p.mesh);
            });
            particles = [];

            if (levelIndex >= gameLevels.length) {
                gameOver("All Levels Cleared! YOU WIN!", score);
                return;
            }

            const levelData = gameLevels[levelIndex];
            currentLevel = levelIndex;
            ammo = levelData.ammo;
            maxAmmo = levelData.ammo;

            levelData.targets.forEach(tData => {
                const targetMesh = createTarget(tData);
                scene.add(targetMesh);
                activeTargets.push({ mesh: targetMesh, hit: false, ...tData });
            });

            showMessage(`Level ${levelIndex + 1}: ${levelData.message}`, 3000);
            updateUI();
            levelInProgress = true;
        }

        function checkLevelComplete() {
            const unhitTargets = activeTargets.filter(t => !t.hit);
            if (unhitTargets.length === 0 && levelInProgress) {
                levelInProgress = false; // Prevent multiple triggers
                showMessage(`Level ${currentLevel + 1} Cleared!`, 2000, 'lightgreen');
                if (levelUpSound && Tone.context.state === 'running') levelUpSound.triggerAttackRelease("C5", "0.5s", Tone.now() + 0.1);
                
                setTimeout(() => {
                    currentLevel++;
                    loadLevel(currentLevel);
                }, 2500);
            } else if (ammo <= 0 && unhitTargets.length > 0 && levelInProgress) {
                gameOver("Out of Ammo! Mission Failed.", score);
            }
        }

        function gameOver(title, finalScore) {
            levelInProgress = false;
            gameStarted = false;
            gameOverTitle.textContent = title;
            finalScoreSpan.textContent = finalScore;
            gameOverScreen.style.display = 'flex';
            if (document.pointerLockElement) document.exitPointerLock();
        }

        function shoot() {
            if (!levelInProgress) return;
            if (ammo <= 0) {
                if (dryFireSound && dryFireSound.loaded && Tone.context.state === 'running') dryFireSound.start();
                return;
            }

            ammo--;
            // Corrected: NoiseSynth.triggerAttackRelease takes duration, not a note.
            if (shotSound && Tone.context.state === 'running') shotSound.triggerAttackRelease("8n");

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const liveTargets = activeTargets.filter(t => !t.hit).map(t => t.mesh);
            const intersects = raycaster.intersectObjects(liveTargets);

            if (intersects.length > 0) {
                const hitObject = intersects[0].object;
                const targetData = activeTargets.find(t => t.mesh === hitObject);

                if (targetData && !targetData.hit) {
                    targetData.hit = true;
                    score += targetData.points;
                    if (hitSound && Tone.context.state === 'running') hitSound.triggerAttackRelease("C2", "8n");
                    if (explosionSound && Tone.context.state === 'running') explosionSound.triggerAttackRelease("8n");
                    
                    createExplosion(hitObject.position.clone(), hitObject.material.color.clone());
                    if (hitObject.parent) scene.remove(hitObject);
                    
                    checkLevelComplete();
                }
            }
            updateUI();
        }

        // --- Event Handlers & UI ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            if (!gameStarted || document.pointerLockElement !== gameCanvas) return;
            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;
            const sensitivity = isScoped ? 0.001 : 0.002;
            camera.rotation.y -= movementX * sensitivity;
            camera.rotation.x -= movementY * sensitivity;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
        }

        function onMouseDown(event) {
            if (!gameStarted) return;
            if (document.pointerLockElement !== gameCanvas) {
                gameCanvas.requestPointerLock();
                return;
            }
            if (event.button === 0) shoot();
            else if (event.button === 2) toggleScope();
        }

        function toggleScope() {
            if (!gameStarted) return;
            isScoped = !isScoped;
            camera.fov = isScoped ? scopedFov : normalFov;
            scopeOverlay.style.display = isScoped ? 'block' : 'none';
            scopeLensEffect.style.display = isScoped ? 'block' : 'none';
            if (sniperRifle) sniperRifle.visible = !isScoped;
            camera.updateProjectionMatrix();
        }

        function updateUI() {
            scorePanel.textContent = `Score: ${score}`;
            levelPanel.textContent = `Level: ${currentLevel + 1}`;
            ammoPanel.textContent = `Ammo: ${ammo}/${maxAmmo}`;
            targetsLeftPanel.textContent = `Targets Left: ${activeTargets.filter(t => !t.hit).length}`;
        }

        function showMessage(msg, duration = 2000, color = 'white') {
            messagePanel.textContent = msg;
            messagePanel.style.color = color;
            messagePanel.style.display = 'block';
            setTimeout(() => { messagePanel.style.display = 'none'; }, duration);
        }

        // --- Effects & Animation ---
        function createTarget(targetData) {
            const geometry = new THREE.CylinderGeometry(targetData.size.rTop, targetData.size.rBottom, targetData.size.h, 16);
            const material = new THREE.MeshStandardMaterial({ color: targetData.color });
            const cylinder = new THREE.Mesh(geometry, material);
            cylinder.position.copy(targetData.pos);
            cylinder.castShadow = true;
            cylinder.userData = { ...targetData };
            return cylinder;
        }

        function createExplosion(position, color) {
            const particleCount = 20;
            const particleMaterial = new THREE.MeshBasicMaterial({ color: color, transparent: true });
            const particleGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            for (let i = 0; i < particleCount; i++) {
                const particleMesh = new THREE.Mesh(particleGeometry, particleMaterial.clone());
                particleMesh.position.copy(position);
                const velocity = new THREE.Vector3((Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)).normalize().multiplyScalar(0.5);
                particles.push({ mesh: particleMesh, velocity: velocity, life: 1.0 });
                scene.add(particleMesh);
            }
        }

        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.velocity.y -= 0.005; // Gravity
                p.mesh.position.add(p.velocity);
                p.life -= deltaTime * 1.5;
                p.mesh.material.opacity = p.life;
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    if (p.mesh.geometry) p.mesh.geometry.dispose();
                    if (p.mesh.material) p.mesh.material.dispose();
                    particles.splice(i, 1);
                }
            }
        }

        function updateMovingTargets() {
            if (!levelInProgress) return;
            activeTargets.forEach(targetData => {
                if (targetData.moving && !targetData.hit) {
                    const target = targetData.mesh;
                    const moveData = target.userData;
                    if (!moveData.initialPos) moveData.initialPos = target.position.clone();
                    // Using a simpler sine wave for smooth back-and-forth movement
                    if (moveData.moveAxis === 'x') {
                        target.position.x = moveData.initialPos.x + Math.sin(Date.now() * 0.001 * moveData.moveSpeed * 100) * (moveData.moveRange / 2);
                    } else if (moveData.moveAxis === 'y') {
                        target.position.y = moveData.initialPos.y + Math.sin(Date.now() * 0.001 * moveData.moveSpeed * 100) * (moveData.moveRange / 2);
                    }
                }
            });
        }

        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            const deltaTime = (time - (lastTime || time)) / 1000;
            lastTime = time;
            updateParticles(deltaTime);
            updateMovingTargets();
            renderer.render(scene, camera);
        }

        // --- Start Application ---
        init();
    </script>
</body>
</html>
